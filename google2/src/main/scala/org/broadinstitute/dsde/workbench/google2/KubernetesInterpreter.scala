package org.broadinstitute.dsde.workbench.google2

import cats.effect.concurrent.Semaphore
import cats.effect.{Async, Blocker, ContextShift, Timer}
import io.chrisdavenport.log4cats.StructuredLogger
import io.kubernetes.client.apis.CoreV1Api
import org.broadinstitute.dsde.workbench.RetryConfig
import cats.implicits._
import io.kubernetes.client.ApiException

// This uses a kubernetes client library to make calls to the kubernetes API. The client library is autogenerated from the kubernetes API.
// It is highly recommended to use the kubernetes API docs here https://kubernetes.io/docs/reference/generated/kubernetes-api as opposed to the client library documentation

class KubernetesInterpreter[F[_]: Async: StructuredLogger: Timer: ContextShift](

                                                                                blocker: Blocker,
                                                                                blockerBound: Semaphore[F],
                                                                                 kubernetesClient: CoreV1Api,
                                                                                 retryConfig: RetryConfig
                                                                               ) extends KubernetesService[F] {

  // https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#podspec-v1-core
  override def createPod(pod: KubernetesPod, namespace: KubernetesNamespace): F[Unit] = {
    Async[F].delay(kubernetesClient.createNamespacedPod(namespace.name.value, pod.getJavaSerialization, null, null, null))
  }

  //why we use a service over a deployment https://matthewpalmer.net/kubernetes-app-developer/articles/service-kubernetes-example-tutorial.html
  //sevices can be applied to pods/containers, while deployments are more for pre-creating pods
  def createService(service: KubernetesServiceKind, namespace: KubernetesNamespace): F[Unit] = {
    val result = for {
      _ <- Async[F].delay(
          kubernetesClient.createNamespacedService(namespace.name.value, service.getJavaSerialization, null, null, null)
        )
    } yield ()

    result.handleErrorWith(e => e match {
      case e: ApiException => Async[F].delay(println(e.getResponseBody()))
      case _ => Async[F].unit
    })
  }

  override def createNamespace(namespace: KubernetesNamespace): F[Unit] = {
    for {
     _ <- Async[F].delay(kubernetesClient.createNamespace(namespace.getJavaSerialization, null, null, null))
    } yield ()
  }

 }
