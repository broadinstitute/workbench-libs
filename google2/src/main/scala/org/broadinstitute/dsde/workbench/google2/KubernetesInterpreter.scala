package org.broadinstitute.dsde.workbench.google2

import cats.effect.concurrent.Semaphore
import cats.effect.{Async, Blocker, ContextShift, Timer}
import io.chrisdavenport.log4cats.StructuredLogger
import io.kubernetes.client.apis.CoreV1Api
import org.broadinstitute.dsde.workbench.RetryConfig
import cats.implicits._
import cats.mtl.ApplicativeAsk
import io.kubernetes.client.ApiException
import org.broadinstitute.dsde.workbench.model.TraceId

// This uses a kubernetes client library to make calls to the kubernetes API. The client library is autogenerated from the kubernetes API.
// It is highly recommended to use the kubernetes API docs here https://kubernetes.io/docs/reference/generated/kubernetes-api as opposed to the client library documentation

class KubernetesInterpreter[F[_]: Async: StructuredLogger: Timer: ContextShift](
                                                                                 kubernetesClient: CoreV1Api,
                                                                                 blocker: Blocker,
                                                                                 blockerBound: Semaphore[F],
                                                                                 retryConfig: RetryConfig
                                                                               ) extends KubernetesService[F] {

  // https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#podspec-v1-core
  override def createPod(pod: KubernetesPod, namespace: KubernetesNamespace)
                        (implicit ev: ApplicativeAsk[F, TraceId]): F[Unit] =
    kubernetesCallWrapper(
      for {
       _ <- Async[F].delay(kubernetesClient.createNamespacedPod(namespace.name.value, pod.getJavaSerialization, null, null, null))
      } yield ()
    )


  //why we use a service over a deployment https://matthewpalmer.net/kubernetes-app-developer/articles/service-kubernetes-example-tutorial.html
  //sevices can be applied to pods/containers, while deployments are for pre-creating pods/containers
  def createService(service: KubernetesServiceKind, namespace: KubernetesNamespace)
                   (implicit ev: ApplicativeAsk[F, TraceId]): F[Unit] =
    kubernetesCallWrapper(
      for {
        _ <- Async[F].delay(kubernetesClient.createNamespacedService(namespace.name.value, service.getJavaSerialization, null, null, null))
      } yield ()
    )

  override def createNamespace(namespace: KubernetesNamespace)
                              (implicit ev: ApplicativeAsk[F, TraceId]): F[Unit] =
    kubernetesCallWrapper(
      for {
       _ <- Async[F].delay(kubernetesClient.createNamespace(namespace.getJavaSerialization, null, null, null))
      } yield ()
    )

  //TODO: retry once we know what kubernetes codes are applicable
  private def kubernetesCallWrapper[A](fa: F[A]): F[A] =
    blockerBound.withPermit(blocker.blockOn(
      fa
    ).onError { //we aren't handling it here, it will be bubbled up, but we want to print a more helpful message
      case e: ApiException => Async[F].delay(println(e.getResponseBody()))
    })

 }
